# CST Examples

## Overview

This document provides concrete examples of CST structures for key MOO language constructs, showing the exact tree structure generated by tree-sitter-moo.

## Table of Contents

- [Basic Constructs](#basic-constructs)
- [Binding Patterns](#binding-patterns)
- [Functions and Lambdas](#functions-and-lambdas)
- [Control Flow](#control-flow)
- [Data Structures](#data-structures)
- [Object Access](#object-access)
- [Complex Expressions](#complex-expressions)

## Basic Constructs

### Variable Assignment
```moo
let x = 42;
```

**CST:**
```
(program
  (local_assignment
    target: (identifier)
    value: (INTEGER)))
```

### Constant Assignment
```moo
const PI = 3.14159;
```

**CST:**
```
(program
  (const_assignment
    target: (identifier)
    value: (FLOAT)))
```

### Function Call
```moo
result = calculate(a, b, c);
```

**CST:**
```
(program
  (assignment_expr
    left: (identifier)
    right: (call
      function: (identifier)
      arguments: (arglist
        arguments: (argument
          value: (identifier))
        arguments: (argument
          value: (identifier))
        arguments: (argument
          value: (identifier))))))
```

## Binding Patterns

### Simple Destructuring
```moo
let {x, y, z} = coordinates;
```

**CST:**
```
(program
  (local_assignment
    target: (binding_pattern
      parameters: (binding_target
        name: (identifier))
      parameters: (binding_target
        name: (identifier))
      parameters: (binding_target
        name: (identifier)))
    value: (identifier)))
```

### Complex Binding with Optional and Rest
```moo
const {first, ?second = "default", @remaining} = data;
```

**CST:**
```
(program
  (const_assignment
    target: (binding_pattern
      parameters: (binding_target
        name: (identifier))
      parameters: (binding_optional
        name: (identifier)
        default: (STRING))
      parameters: (binding_rest
        name: (identifier)))
    value: (identifier)))
```

### Assignment Expression with Binding
```moo
{success, error} = process_request();
```

**CST:**
```
(program
  (assignment_expr
    left: (binding_pattern
      parameters: (binding_target
        name: (identifier))
      parameters: (binding_target
        name: (identifier)))
    right: (call
      function: (identifier)
      arguments: (arglist))))
```

## Functions and Lambdas

### Simple Lambda
```moo
let add = {x, y} => x + y;
```

**CST:**
```
(program
  (local_assignment
    target: (identifier)
    value: (lambda_expr
      params: (lambda_params
        (parameter_list
          (binding_target
            name: (identifier))
          (binding_target
            name: (identifier))))
      body: (binary_expr
        left: (identifier)
        operator: "+"
        right: (identifier)))))
```

### Lambda with Complex Parameters
```moo
let handler = {?code = E_NONE, @args} => process(code, args);
```

**CST:**
```
(program
  (local_assignment
    target: (identifier)
    value: (lambda_expr
      params: (lambda_params
        (parameter_list
          (binding_optional
            name: (identifier)
            default: (identifier))
          (binding_rest
            name: (identifier))))
      body: (call
        function: (identifier)
        arguments: (arglist
          arguments: (argument
            value: (identifier))
          arguments: (argument
            value: (identifier)))))))
```

### Named Function
```moo
fn factorial(n)
    if (n <= 1)
        return 1;
    else
        return n * factorial(n - 1);
    endif
endfn
```

**CST:**
```
(program
  (fn_statement
    name: (identifier)
    params: (lambda_params
      (parameter_list
        (binding_target
          name: (identifier))))
    body: (if
      condition: (binary_expr
        left: (identifier)
        operator: "<="
        right: (INTEGER))
      body: (return
        value: (INTEGER))
      elseif_clauses: 
      else_clause: (_else
        body: (return
          value: (binary_expr
            left: (identifier)
            operator: "*"
            right: (call
              function: (identifier)
              arguments: (arglist
                arguments: (argument
                  value: (binary_expr
                    left: (identifier)
                    operator: "-"
                    right: (INTEGER)))))))))))
```

### Anonymous Function Expression
```moo
let processor = fn(data) return process(data) + 1; endfn;
```

**CST:**
```
(program
  (local_assignment
    target: (identifier)
    value: (fn_expr
      params: (lambda_params
        (parameter_list
          (binding_target
            name: (identifier))))
      body: (return
        value: (binary_expr
          left: (call
            function: (identifier)
            arguments: (arglist
              arguments: (argument
                value: (identifier))))
          operator: "+"
          right: (INTEGER))))))
```

## Control Flow

### If-Else Statement
```moo
if (x > 0)
    return "positive";
elseif (x < 0)
    return "negative";
else
    return "zero";
endif
```

**CST:**
```
(program
  (if
    condition: (binary_expr
      left: (identifier)
      operator: ">"
      right: (INTEGER))
    body: (return
      value: (STRING))
    elseif_clauses: (_elseif
      condition: (binary_expr
        left: (identifier)
        operator: "<"
        right: (INTEGER))
      body: (return
        value: (STRING)))
    else_clause: (_else
      body: (return
        value: (STRING)))))
```

### While Loop with Label
```moo
while outer (condition)
    if (should_break)
        break outer;
    endif
endwhile
```

**CST:**
```
(program
  (while
    label: (identifier)
    condition: (identifier)
    body: (if
      condition: (identifier)
      body: (break
        label: (identifier))
      elseif_clauses: 
      else_clause: )))
```

### For Loop
```moo
for item in (my_list)
    process(item);
endfor
```

**CST:**
```
(program
  (for
    variable: (identifier)
    iterable: (for_iterable
      expression: (identifier))
    body: (call
      function: (identifier)
      arguments: (arglist
        arguments: (argument
          value: (identifier))))))
```

### For Range Loop
```moo
for i in [1..10]
    print(i);
endfor
```

**CST:**
```
(program
  (for
    variable: (identifier)
    iterable: (for_iterable
      start: (INTEGER)
      end: (INTEGER))
    body: (call
      function: (identifier)
      arguments: (arglist
        arguments: (argument
          value: (identifier))))))
```

### Try-Catch-Finally
```moo
try
    risky_operation();
except e (E_PERM, E_ARGS)
    handle_error(e);
finally
    cleanup();
endtry
```

**CST:**
```
(program
  (try
    body: (call
      function: (identifier)
      arguments: (arglist))
    except: (except
      variable: (identifier)
      codes: (ERR (ERR))
      body: (call
        function: (identifier)
        arguments: (arglist
          arguments: (argument
            value: (identifier)))))
    finally: 
      body: (call
        function: (identifier)
        arguments: (arglist))))
```

## Data Structures

### List Literal
```moo
let numbers = {1, 2, 3, @more_numbers};
```

**CST:**
```
(program
  (local_assignment
    target: (identifier)
    value: (list
      elements: (INTEGER)
      elements: (INTEGER)
      elements: (INTEGER)
      elements: (scatter_element
        expression: (identifier)))))
```

### Map Literal
```moo
let person = ["name" -> "Alice", "age" -> 30, "active" -> true];
```

**CST:**
```
(program
  (local_assignment
    target: (identifier)
    value: (map
      entries: (pair
        key: (STRING)
        value: (STRING))
      entries: (pair
        key: (STRING)
        value: (INTEGER))
      entries: (pair
        key: (STRING)
        value: (boolean)))))
```

### Flyweight Object
```moo
let enhanced = <base_obj, ["priority" -> "high"], {1, 2, 3}>;
```

**CST:**
```
(program
  (local_assignment
    target: (identifier)
    value: (flyweight
      parent: (identifier)
      properties: (map
        entries: (pair
          key: (STRING)
          value: (STRING)))
      values: (list
        elements: (INTEGER)
        elements: (INTEGER)
        elements: (INTEGER)))))
```

## Object Access

### Property Access Chain
```moo
let value = obj.property.nested_property;
```

**CST:**
```
(program
  (local_assignment
    target: (identifier)
    value: (property_access
      object: (property_access
        object: (identifier)
        property: (identifier))
      property: (identifier))))
```

### Dynamic Property Access
```moo
let prop = obj.(dynamic_prop_name);
```

**CST:**
```
(program
  (local_assignment
    target: (identifier)
    value: (property_access
      object: (identifier)
      property: (identifier))))
```

### Method Call Chain
```moo
result = obj:method1(arg):method2():method3(a, b);
```

**CST:**
```
(program
  (assignment_expr
    left: (identifier)
    right: (method_call
      object: (method_call
        object: (method_call
          object: (identifier)
          method: (identifier)
          arguments: (arglist
            arguments: (argument
              value: (identifier))))
        method: (identifier)
        arguments: (arglist))
      method: (identifier)
      arguments: (arglist
        arguments: (argument
          value: (identifier))
        arguments: (argument
          value: (identifier))))))
```

### Array Indexing and Slicing
```moo
let item = array[5];
let subset = array[1..10];
let tail = array[start..$];
```

**CST:**
```
(program
  (local_assignment
    target: (identifier)
    value: (index_access
      object: (identifier)
      index: (INTEGER)))
  (local_assignment
    target: (identifier)
    value: (slice
      object: (identifier)
      from: (INTEGER)
      to: (INTEGER)))
  (local_assignment
    target: (identifier)
    value: (slice
      object: (identifier)
      from: (identifier)
      to: (range_end))))
```

## Complex Expressions

### Ternary Conditional
```moo
let result = condition ? true_value | false_value;
```

**CST:**
```
(program
  (local_assignment
    target: (identifier)
    value: (conditional_expr
      condition: (identifier)
      consequence: (identifier)
      alternative: (identifier))))
```

### Nested Ternary
```moo
let grade = score >= 90 ? "A" | score >= 80 ? "B" | "C";
```

**CST:**
```
(program
  (local_assignment
    target: (identifier)
    value: (conditional_expr
      condition: (binary_expr
        left: (identifier)
        operator: ">="
        right: (INTEGER))
      consequence: (STRING)
      alternative: (conditional_expr
        condition: (binary_expr
          left: (identifier)
          operator: ">="
          right: (INTEGER))
        consequence: (STRING)
        alternative: (STRING)))))
```

### Complex Binary Expression
```moo
let complex = (a + b) * (c - d) / (e ^ f);
```

**CST:**
```
(program
  (local_assignment
    target: (identifier)
    value: (binary_expr
      left: (binary_expr
        left: (binary_expr
          left: (identifier)
          operator: "+"
          right: (identifier))
        operator: "*"
        right: (binary_expr
          left: (identifier)
          operator: "-"
          right: (identifier)))
      operator: "/"
      right: (binary_expr
        left: (identifier)
        operator: "^"
        right: (identifier)))))
```

### Try Expression
```moo
let safe_result = `risky_operation() ! E_PERM => "access_denied"`;
```

**CST:**
```
(program
  (local_assignment
    target: (identifier)
    value: (try_expr
      expression: (call
        function: (identifier)
        arguments: (arglist))
      codes: (ERR)
      fallback: (STRING))))
```

### Range Comprehension
```moo
let squares = {x * x for x in [1..10]};
```

**CST:**
```
(program
  (local_assignment
    target: (identifier)
    value: (range_comprehension
      expression: (binary_expr
        left: (identifier)
        operator: "*"
        right: (identifier))
      variable: (identifier)
      iterable: (for_iterable
        start: (INTEGER)
        end: (INTEGER)))))
```

### Object and System References
```moo
let obj_ref = #123;
let sym_obj = #special_object;
let sys_prop = $current_user;
let symbol_val = 'my_symbol;
```

**CST:**
```
(program
  (local_assignment
    target: (identifier)
    value: (objid
      number: (INTEGER)))
  (local_assignment
    target: (identifier)
    value: (objid
      symbol: (identifier)))
  (local_assignment
    target: (identifier)
    value: (sysprop
      name: (identifier)))
  (local_assignment
    target: (identifier)
    value: (symbol
      name: (identifier))))
```

These examples demonstrate the complete CST structure for all major MOO language constructs, showing how the flattened binding pattern system and comprehensive named fields create a well-structured and accessible parse tree.