# Tree-sitter-moo CST Reference

## Overview

This document provides a comprehensive reference for the Concrete Syntax Tree (CST) structure generated by the tree-sitter-moo parser. The CST preserves all syntactic information from the source code, including whitespace and comments, making it ideal for language tools, formatters, and analysis.

## Table of Contents

- [Program Structure](#program-structure)
- [Statements](#statements)
- [Expressions](#expressions)
- [Data Structures](#data-structures)
- [Binding Patterns](#binding-patterns)
- [Functions and Lambdas](#functions-and-lambdas)
- [Object Definition](#object-definition)
- [Named Field Reference](#named-field-reference)
- [CST Hierarchy Examples](#cst-hierarchy-examples)

## Program Structure

### `program`
The root node of every MOO parse tree.

**Structure:**
```
program
├── object_definition (for .objdef files)
└── _statement* (for .moo files)
```

**Named Fields:** None

**Example:**
```moo
let x = 5;
return x + 1;
```
```
(program
  (local_assignment ...)
  (return ...))
```

---

## Statements

### Control Flow Statements

#### `break`
Unconditional or labeled break statement.

**Named Fields:**
- `label` (optional): `identifier` - Label for labeled break

**Structure:**
```
break
└── label? (identifier)
```

**Examples:**
```moo
break;           // Simple break
break outer;     // Labeled break
```

#### `continue` 
Unconditional or labeled continue statement.

**Named Fields:**
- `label` (optional): `identifier` - Label for labeled continue

**Structure:**
```
continue
└── label? (identifier)
```

#### `return`
Return statement with optional value.

**Named Fields:**
- `value` (optional): `_expr` - Expression to return

**Structure:**
```
return
└── value? (_expr)
```

**Examples:**
```moo
return;          // Return void
return x + 1;    // Return expression
```

#### `block`
Block statement with begin/end delimiters.

**Named Fields:**
- `body`: `_statement*` - Statements in block

**Structure:**
```
block
└── body (_statement*)
```

**Example:**
```moo
begin
    let x = 5;
    return x;
end
```

#### `if`
Conditional statement with optional elseif and else clauses.

**Named Fields:**
- `condition`: `_expr` - If condition
- `body`: `_statement*` - If body statements
- `elseif_clauses`: `_elseif*` - Elseif clauses
- `else_clause` (optional): `_else` - Else clause

**Structure:**
```
if
├── condition (_expr)
├── body (_statement*)
├── elseif_clauses (_elseif*)
└── else_clause? (_else)
```

#### `_elseif`
Elseif clause within if statement.

**Named Fields:**
- `condition`: `_expr` - Elseif condition
- `body`: `_statement*` - Elseif body statements

#### `_else`
Else clause within if statement.

**Named Fields:**
- `body`: `_statement*` - Else body statements

#### `while`
While loop with optional label.

**Named Fields:**
- `label` (optional): `identifier` - Loop label
- `condition`: `_expr` - Loop condition
- `body`: `_statement*` - Loop body statements

**Structure:**
```
while
├── label? (identifier)
├── condition (_expr)
└── body (_statement*)
```

#### `for`
For-in loop statement.

**Named Fields:**
- `variable`: `identifier` - Loop variable
- `iterable`: `for_iterable` - Iterable expression
- `body`: `_statement*` - Loop body statements

**Structure:**
```
for
├── variable (identifier)
├── iterable (for_iterable)
└── body (_statement*)
```

#### `for_iterable`
Iterable expression for for loops.

**Named Fields (Range form):**
- `start`: `_expr` - Range start
- `end`: `_expr` - Range end

**Named Fields (Expression form):**
- `expression`: `_expr` - Single expression

**Examples:**
```moo
for x in [1..10]        // Range form
for item in (my_list)   // Expression form
```

#### `fork`
Fork statement for parallel execution.

**Named Fields:**
- `label` (optional): `identifier` - Fork label
- `expression`: `_expr` - Fork expression
- `body`: `_statement*` - Fork body statements

#### `try`
Try-catch-finally statement.

**Named Fields:**
- `body`: `_statement*` - Try body statements
- `except`: `except*` - Exception handlers
- `finally` (optional): Has nested `body` field for finally statements

#### `except`
Exception handler within try statement.

**Named Fields:**
- `variable` (optional): `identifier` - Exception variable
- `codes`: `_try_expr_codes` - Exception codes to catch
- `body`: `_statement*` - Handler body statements

### Assignment Statements

#### `local_assignment`
Local variable assignment with let.

**Named Fields:**
- `target`: `identifier | binding_pattern` - Assignment target
- `value`: `_expr` - Assigned value

**Structure:**
```
local_assignment
├── target (identifier | binding_pattern)
└── value (_expr)
```

**Examples:**
```moo
let x = 5;                    // Simple assignment
let {a, b, @rest} = list;     // Destructuring assignment
```

#### `const_assignment`
Constant assignment with const.

**Named Fields:**
- `target`: `identifier | binding_pattern` - Assignment target
- `value`: `_expr` - Assigned value

#### `global_assignment`
Global variable declaration.

**Named Fields:**
- `name`: `identifier` - Global variable name
- `value` (optional): `_expr` - Initial value

---

## Expressions

### Basic Expressions

#### `assignment_expr`
Assignment expression (not statement).

**Named Fields:**
- `left`: `identifier | binding_pattern` - Left-hand side
- `right`: `_expr` - Right-hand side

**Structure:**
```
assignment_expr
├── left (identifier | binding_pattern)
└── right (_expr)
```

#### `conditional_expr`
Ternary conditional expression.

**Named Fields:**
- `condition`: `_expr` - Condition
- `consequence`: `_expr` - True branch
- `alternative`: `_expr` - False branch

**Structure:**
```
conditional_expr
├── condition (_expr)
├── consequence (_expr)
└── alternative (_expr)
```

**Example:**
```moo
x > 0 ? "positive" | "non-positive"
```

#### `binary_expr`
Binary operation expression.

**Named Fields:**
- `left`: `_expr` - Left operand
- `operator`: Token - Binary operator (`+`, `-`, `*`, `/`, `%`, `^`, `==`, `!=`, `<`, `<=`, `>`, `>=`, `in`, `&&`, `||`, etc.)
- `right`: `_expr` - Right operand

**Structure:**
```
binary_expr
├── left (_expr)
├── operator (token)
└── right (_expr)
```

#### `unary_expr`
Unary operation expression.

**Named Fields:**
- `operator`: Token - Unary operator (`!`, `-`)
- `operand`: `_expr` - Operand

**Structure:**
```
unary_expr
├── operator (token)
└── operand (_expr)
```

### Access Expressions

#### `property_access`
Property access with dot notation.

**Named Fields:**
- `object`: `_expr` - Object being accessed
- `property`: `identifier | (_expr)` - Property name (static or dynamic)

**Structure:**
```
property_access
├── object (_expr)
└── property (identifier | _expr)
```

**Examples:**
```moo
obj.property          // Static property
obj.(dynamic_prop)    // Dynamic property
```

#### `method_call`
Method call with colon notation.

**Named Fields:**
- `object`: `_expr` - Object being called
- `method`: `identifier | (_expr)` - Method name (static or dynamic)
- `arguments`: `arglist` - Method arguments

**Structure:**
```
method_call
├── object (_expr)
├── method (identifier | _expr)
└── arguments (arglist)
```

#### `index_access`
Array/object indexing with brackets.

**Named Fields:**
- `object`: `_expr` - Object being indexed
- `index`: `_index_expr` - Index expression

**Structure:**
```
index_access
├── object (_expr)
└── index (_index_expr)
```

#### `slice`
Array slicing with range.

**Named Fields:**
- `object`: `_expr` - Object being sliced
- `from`: `_index_expr` - Start index
- `to`: `_index_expr` - End index

**Structure:**
```
slice
├── object (_expr)
├── from (_index_expr)
└── to (_index_expr)
```

**Example:**
```moo
array[1..5]     // Slice from 1 to 5
array[start..$] // Slice from start to end
```

#### `call`
Function call expression.

**Named Fields:**
- `function`: `identifier | (_expr)` - Function being called
- `arguments`: `arglist` - Function arguments

**Structure:**
```
call
├── function (identifier | _expr)
└── arguments (arglist)
```

#### `try_expr`
Try expression with error handling.

**Named Fields:**
- `expression`: `_expr` - Expression to try
- `codes`: `_try_expr_codes` - Error codes to catch
- `fallback` (optional): `_expr` - Fallback expression

**Structure:**
```
try_expr
├── expression (_expr)
├── codes (_try_expr_codes)
└── fallback? (_expr)
```

**Example:**
```moo
`risky_operation() ! E_PERM => "Permission denied"`
```

---

## Data Structures

### `list`
List literal with curly braces.

**Named Fields:**
- `elements`: `_list_element*` - List elements (comma-separated)

**Structure:**
```
list
└── elements (_list_element*)
```

**Examples:**
```moo
{1, 2, 3}           // Simple list
{a, @rest_items}    // List with scatter
```

#### `scatter_element`
Scatter operator in list context.

**Named Fields:**
- `expression`: `_expr` - Expression to scatter

**Structure:**
```
scatter_element
└── expression (_expr)
```

### `map`
Map/dictionary literal with square brackets.

**Named Fields:**
- `entries`: `pair*` - Key-value pairs (comma-separated)

**Structure:**
```
map
└── entries (pair*)
```

#### `pair`
Key-value pair in map.

**Named Fields:**
- `key`: `_expr` - Key expression
- `value`: `_expr` - Value expression

**Structure:**
```
pair
├── key (_expr)
└── value (_expr)
```

**Example:**
```moo
["name" -> "Alice", "age" -> 30]
```

### `flyweight`
Flyweight object notation.

**Named Fields:**
- `parent`: `_expr` - Parent object
- `properties` (optional): `map` - Property overrides
- `values` (optional): `list` - Value overrides

**Structure:**
```
flyweight
├── parent (_expr)
├── properties? (map)
└── values? (list)
```

**Example:**
```moo
<#123, ["name" -> "Bob"], {1, 2, 3}>
```

---

## Binding Patterns

Modern unified binding pattern system used across assignments, lambda parameters, and function parameters.

### `binding_pattern`
**Flattened structure** - parameters are direct children, not nested under parameter_list.

**Named Fields:**
- `parameters`: Multiple `binding_target | binding_optional | binding_rest` - Parameter bindings

**Structure:**
```
binding_pattern
├── parameters (binding_target)
├── parameters (binding_optional)
└── parameters (binding_rest)
```

**Key Benefits:**
- Simplified access: `pattern.parameters[i].name`
- Consistent field names across all parameter types
- Better tooling support

### `binding_target`
Simple parameter binding.

**Named Fields:**
- `name`: `identifier` - Parameter name

**Structure:**
```
binding_target
└── name (identifier)
```

### `binding_optional`
Optional parameter with default value.

**Named Fields:**
- `name`: `identifier` - Parameter name
- `default` (optional): `_expr` - Default value

**Structure:**
```
binding_optional
├── name (identifier)
└── default? (_expr)
```

### `binding_rest`
Rest parameter (collects remaining arguments).

**Named Fields:**
- `name`: `identifier` - Rest parameter name

**Structure:**
```
binding_rest
└── name (identifier)
```

**Example:**
```moo
{a, ?b = 10, @rest} = some_list;
```
```
(binding_pattern
  parameters: (binding_target name: (identifier))
  parameters: (binding_optional name: (identifier) default: (INTEGER))
  parameters: (binding_rest name: (identifier)))
```

---

## Functions and Lambdas

### `lambda_expr`
Lambda (arrow) function expression.

**Named Fields:**
- `params` (optional): `lambda_params` - Parameter list
- `body`: `_expr` - Lambda body expression

**Structure:**
```
lambda_expr
├── params? (lambda_params)
└── body (_expr)
```

### `lambda_params`
Parameter list for lambdas and functions.

**Structure:**
```
lambda_params
└── parameter_list
    ├── binding_target
    ├── binding_optional
    └── binding_rest
```

**Examples:**
```moo
{x, y} => x + y                    // Simple lambda
{?code = E_NONE, @args} => ...     // Lambda with optional and rest
```

### `fn_expr`
Function expression (anonymous function).

**Named Fields:**
- `params` (optional): `lambda_params` - Parameter list
- `body`: `_statement*` - Function body statements

**Structure:**
```
fn_expr
├── params? (lambda_params)
└── body (_statement*)
```

### `fn_statement`
Named function statement.

**Named Fields:**
- `name`: `identifier` - Function name
- `params` (optional): `lambda_params` - Parameter list
- `body`: `_statement*` - Function body statements

**Structure:**
```
fn_statement
├── name (identifier)
├── params? (lambda_params)
└── body (_statement*)
```

**Example:**
```moo
fn factorial(n)
    if (n <= 1)
        return 1;
    else
        return n * factorial(n - 1);
    endif
endfn
```

---

## Object Definition

Object definition syntax for MOO objects (.objdef files).

### `object_definition`
Top-level object definition.

**Named Fields:**
- `name`: `identifier` - Object name

**Structure:**
```
object_definition
├── name (identifier)
└── _object_member*
```

### `object_property`
Simple property assignment within object.

**Named Fields:**
- `name`: `identifier` - Property name
- `value`: `_expr` - Property value

### `property_definition`
Full property definition with attributes.

**Named Fields:**
- `name`: `identifier` - Property name
- `value`: `_expr` - Property value

**Structure:**
```
property_definition
├── name (identifier)
├── property_attrs? (property_attrs)
└── value (_expr)
```

### `property_attrs`
Property attributes in parentheses.

**Named Fields:**
- `name`: `identifier` - Attribute name (per attribute)
- `value`: `_expr` - Attribute value (per attribute)

### `verb_definition`
Verb definition within object.

**Named Fields:**
- `name`: `identifier | STRING` - Verb name

**Structure:**
```
verb_definition
├── name (identifier | STRING)
├── verb_args (verb_args)
├── verb_attr* (verb_attr)
└── _statement*
```

### `verb_args`
Verb argument specification.

**Named Fields:**
- `dobj`: `identifier` - Direct object parameter
- `prep`: `identifier` - Preposition parameter  
- `iobj`: `identifier` - Indirect object parameter

### `verb_attr`
Verb attribute specification.

**Named Fields:**
- `name`: `identifier` - Attribute name
- `value`: `_expr` - Attribute value

---

## Named Field Reference

### Complete Alphabetical Field List

| Field Name | Used In | Type | Description |
|------------|---------|------|-------------|
| `alternative` | conditional_expr | _expr | False branch of ternary |
| `arguments` | method_call, call, arglist, pass | arglist/argument* | Function/method arguments |
| `body` | block, if, _elseif, _else, while, for, fork, try, except, fn_expr, fn_statement | _statement* | Statement body |
| `codes` | except, try_expr | _try_expr_codes | Exception codes |
| `condition` | if, _elseif, while, conditional_expr | _expr | Conditional expression |
| `consequence` | conditional_expr | _expr | True branch of ternary |
| `default` | binding_optional | _expr | Default parameter value |
| `dobj` | verb_args | identifier | Direct object parameter |
| `elements` | list | _list_element* | List elements |
| `elseif_clauses` | if | _elseif* | Elseif clauses |
| `else_clause` | if | _else | Else clause |
| `end` | for_iterable | _expr | Range end value |
| `entries` | map | pair* | Map key-value pairs |
| `expression` | scatter_element, for_iterable, fork, try_expr | _expr | Expression value |
| `fallback` | try_expr | _expr | Fallback expression |
| `finally` | try | special | Finally block |
| `from` | slice | _index_expr | Slice start index |
| `function` | call | identifier/_expr | Function being called |
| `index` | index_access | _index_expr | Array index |
| `iobj` | verb_args | identifier | Indirect object parameter |
| `iterable` | for | for_iterable | Loop iterable |
| `key` | pair | _expr | Map key |
| `label` | break, continue, while, fork | identifier | Statement label |
| `left` | binary_expr, assignment_expr | _expr | Left operand/side |
| `method` | method_call | identifier/_expr | Method being called |
| `name` | binding_target, binding_optional, binding_rest, symbol, sysprop, global_assignment, fn_statement, object_definition, object_property, property_definition, property_attrs, verb_attr, objid | identifier | Name/identifier |
| `number` | objid | INTEGER | Object number |
| `object` | property_access, method_call, index_access, slice | _expr | Object being accessed |
| `operand` | unary_expr | _expr | Unary operand |
| `operator` | binary_expr, unary_expr | token | Operation operator |
| `parameters` | binding_pattern | binding_target/binding_optional/binding_rest* | Binding parameters |
| `params` | lambda_expr, fn_expr, fn_statement | lambda_params | Function parameters |
| `parent` | flyweight | _expr | Flyweight parent |
| `prep` | verb_args | identifier | Preposition parameter |
| `properties` | flyweight | map | Flyweight properties |
| `property` | property_access | identifier/_expr | Property being accessed |
| `right` | binary_expr, assignment_expr | _expr | Right operand/side |
| `splat` | argument | _expr | Splat argument |
| `start` | for_iterable | _expr | Range start value |
| `symbol` | objid | identifier | Object symbol |
| `target` | local_assignment, const_assignment | identifier/binding_pattern | Assignment target |
| `to` | slice | _index_expr | Slice end index |
| `value` | return, local_assignment, const_assignment, global_assignment, argument, pair, object_property, property_definition, property_attrs, verb_attr | _expr | Value expression |
| `values` | flyweight | list | Flyweight values |
| `variable` | for, except | identifier | Loop/exception variable |

---

## CST Hierarchy Examples

### Complex Binding Pattern
```moo
let {x, ?y = 10, @rest} = getData();
```

**CST Structure:**
```
(program
  (local_assignment
    target: (binding_pattern
      parameters: (binding_target
        name: (identifier))
      parameters: (binding_optional
        name: (identifier)
        default: (INTEGER))
      parameters: (binding_rest
        name: (identifier)))
    value: (call
      function: (identifier)
      arguments: (arglist))))
```

### Lambda with Binding Parameters
```moo
let handler = {?code = E_NONE, @args} => handle(code, args);
```

**CST Structure:**
```
(program
  (local_assignment
    target: (identifier)
    value: (lambda_expr
      params: (lambda_params
        (parameter_list
          (binding_optional
            name: (identifier)
            default: (identifier))
          (binding_rest
            name: (identifier))))
      body: (call
        function: (identifier)
        arguments: (arglist
          arguments: (argument
            value: (identifier))
          arguments: (argument
            value: (identifier)))))))
```

### Method Call Chain
```moo
obj.method1(a, b):method2(c).property
```

**CST Structure:**
```
(property_access
  object: (method_call
    object: (call
      function: (property_access
        object: (identifier)
        property: (identifier))
      arguments: (arglist
        arguments: (argument value: (identifier))
        arguments: (argument value: (identifier))))
    method: (identifier)
    arguments: (arglist
      arguments: (argument value: (identifier))))
  property: (identifier))
```

### Conditional with Complex Expressions
```moo
result = condition ? complex_expr(a, b) | fallback_value;
```

**CST Structure:**
```
(assignment_expr
  left: (identifier)
  right: (conditional_expr
    condition: (identifier)
    consequence: (call
      function: (identifier)
      arguments: (arglist
        arguments: (argument value: (identifier))
        arguments: (argument value: (identifier))))
    alternative: (identifier)))
```

---

## Usage Notes

### Accessing Named Fields
```javascript
// JavaScript example using tree-sitter
const assignmentNode = tree.rootNode.child(0); // local_assignment
const target = assignmentNode.childForFieldName('target');
const value = assignmentNode.childForFieldName('value');

// For binding patterns (flattened structure)
const bindingPattern = target; // binding_pattern
const parameters = bindingPattern.childrenForFieldName('parameters');
parameters.forEach(param => {
  console.log(param.type); // binding_target, binding_optional, or binding_rest
  const name = param.childForFieldName('name');
  console.log(name.text);
});
```

### Tree-sitter Query Examples
```scheme
; Find all function definitions
(fn_statement name: (identifier) @function.name)

; Find all binding patterns
(binding_pattern
  parameters: (binding_target name: (identifier) @param)
  parameters: (binding_optional name: (identifier) @optional-param)
  parameters: (binding_rest name: (identifier) @rest-param))

; Find all method calls
(method_call 
  object: (_) @object
  method: (identifier) @method
  arguments: (arglist) @args)
```

This reference provides the complete structure for understanding and working with tree-sitter-moo CSTs, enabling effective development of language tools, formatters, linters, and other analysis tools.